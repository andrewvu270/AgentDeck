/**
 * Unit Tests for MCPManagerService
 */

import { MCPManagerService } from '../MCPManagerService';
import { query } from '../../../config/database';
import { encrypt, decrypt } from '../../../utils/encryption';
import { MCPClient } from '../MCPClient';

// Mock dependencies
jest.mock('../../../config/database');
jest.mock('../../../utils/encryption');
jest.mock('../MCPClient');

const mockQuery = query as jest.MockedFunction<typeof query>;
const mockEncrypt = encrypt as jest.MockedFunction<typeof encrypt>;
const mockDecrypt = decrypt as jest.MockedFunction<typeof decrypt>;

describe('MCPManagerService', () => {
  let service: MCPManagerService;
  const mockUserId = 'user-123';

  beforeEach(() => {
    service = new MCPManagerService();
    jest.clearAllMocks();
  });

  describe('getMCPConfig', () => {
    it('should return null when no config exists', async () => {
      mockQuery.mockResolvedValue({ rows: [], rowCount: 0 } as any);

      const result = await service.getMCPConfig(mockUserId);

      expect(result).toBeNull();
      expect(mockQuery).toHaveBeenCalledWith(
        expect.stringContaining('SELECT * FROM mcp_configs'),
        [mockUserId]
      );
    });

    it('should return auto-generated config', async () => {
      const mockConfig = {
        id: 'config-123',
        user_id: mockUserId,
        mode: 'auto-generated',
        name: 'Test Config',
        status: 'active',
        api_documentation: 'openapi spec',
        generated_tools: [],
        internal_server_url: 'http://localhost:3000',
        created_at: new Date(),
        updated_at: new Date(),
      };

      mockQuery.mockResolvedValue({ rows: [mockConfig], rowCount: 1 } as any);

      const result = await service.getMCPConfig(mockUserId);

      expect(result).toBeDefined();
      expect(result?.mode).toBe('auto-generated');
      expect(result?.name).toBe('Test Config');
    });

    it('should return BYO-MCP config', async () => {
      const mockConfig = {
        id: 'config-123',
        user_id: mockUserId,
        mode: 'bring-your-own',
        name: 'BYO Config',
        status: 'active',
        external_server_url: 'https://mcp.example.com',
        auth_type: 'bearer',
        discovered_tools: [],
        created_at: new Date(),
        updated_at: new Date(),
      };

      mockQuery.mockResolvedValue({ rows: [mockConfig], rowCount: 1 } as any);

      const result = await service.getMCPConfig(mockUserId);

      expect(result).toBeDefined();
      expect(result?.mode).toBe('bring-your-own');
    });
  });

  describe('createAutoGeneratedMCP', () => {
    it('should create auto-generated MCP config', async () => {
      mockQuery
        .mockResolvedValueOnce({ rows: [], rowCount: 0 } as any) // getMCPConfig returns null
        .mockResolvedValueOnce({
          rows: [{
            id: 'config-123',
            user_id: mockUserId,
            mode: 'auto-generated',
            name: 'Auto MCP',
            status: 'active',
            api_documentation: 'spec',
            generated_tools: [],
            internal_server_url: '',
            created_at: new Date(),
            updated_at: new Date(),
          }],
          rowCount: 1,
        } as any);

      const result = await service.createAutoGeneratedMCP(mockUserId, 'spec', 'Auto MCP');

      expect(result).toBeDefined();
      expect(result.mode).toBe('auto-generated');
      expect(mockQuery).toHaveBeenCalledTimes(2);
    });

    it('should throw error if config already exists', async () => {
      const existingConfig = {
        id: 'config-123',
        userId: mockUserId,
        mode: 'auto-generated' as const,
        name: 'Existing',
        status: 'active' as const,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      mockQuery.mockResolvedValue({ rows: [existingConfig], rowCount: 1 } as any);

      await expect(service.createAutoGeneratedMCP(mockUserId, 'spec'))
        .rejects.toThrow('User already has an MCP configuration');
    });
  });

  describe('createBYOMCP', () => {
    it('should throw error if config already exists', async () => {
      mockQuery.mockResolvedValue({ rows: [{ id: 'existing' }], rowCount: 1 } as any);

      await expect(service.createBYOMCP(mockUserId, 'http://test.com', { type: 'none' }))
        .rejects.toThrow('User already has an MCP configuration');
    });

    it('should throw error if connection validation fails', async () => {
      mockQuery.mockResolvedValue({ rows: [], rowCount: 0 } as any);
      jest.spyOn(service, 'validateConnection').mockResolvedValue(false);

      await expect(service.createBYOMCP(mockUserId, 'http://test.com', { type: 'none' }))
        .rejects.toThrow('Failed to validate MCP server connection');
    });
  });

  describe('switchMCPMode', () => {
    it('should throw error if no config exists', async () => {
      mockQuery.mockResolvedValue({ rows: [], rowCount: 0 } as any);

      await expect(service.switchMCPMode(mockUserId, 'auto-generated'))
        .rejects.toThrow('No MCP configuration found');
    });

    it('should be idempotent if already in target mode', async () => {
      const mockConfig = {
        id: 'config-123',
        user_id: mockUserId,
        mode: 'auto-generated',
        name: 'Test',
        status: 'active',
        created_at: new Date(),
        updated_at: new Date(),
      };

      mockQuery.mockResolvedValue({ rows: [mockConfig], rowCount: 1 } as any);

      await expect(service.switchMCPMode(mockUserId, 'auto-generated'))
        .resolves.not.toThrow();
    });

    it('should delete config when switching modes', async () => {
      const mockConfig = {
        id: 'config-123',
        user_id: mockUserId,
        mode: 'auto-generated',
        name: 'Test',
        status: 'active',
        created_at: new Date(),
        updated_at: new Date(),
      };

      mockQuery
        .mockResolvedValueOnce({ rows: [mockConfig], rowCount: 1 } as any)
        .mockResolvedValueOnce({ rows: [], rowCount: 0 } as any);

      await service.switchMCPMode(mockUserId, 'bring-your-own');

      expect(mockQuery).toHaveBeenCalledWith(
        expect.stringContaining('DELETE FROM mcp_configs'),
        [mockUserId]
      );
    });
  });

  describe('validateConnection', () => {
    it('should return true for valid connection', async () => {
      const mockClient = {
        connect: jest.fn().mockResolvedValue(undefined),
        listTools: jest.fn().mockResolvedValue([]),
        disconnect: jest.fn().mockResolvedValue(undefined),
      };

      (MCPClient as jest.Mock).mockImplementation(() => mockClient);

      const result = await service.validateConnection('http://test.com');

      expect(result).toBe(true);
      expect(mockClient.connect).toHaveBeenCalled();
      expect(mockClient.listTools).toHaveBeenCalled();
      expect(mockClient.disconnect).toHaveBeenCalled();
    });

    it('should return false for invalid connection', async () => {
      const mockClient = {
        connect: jest.fn().mockRejectedValue(new Error('Connection failed')),
        listTools: jest.fn(),
        disconnect: jest.fn(),
      };

      (MCPClient as jest.Mock).mockImplementation(() => mockClient);

      const result = await service.validateConnection('http://invalid.com');

      expect(result).toBe(false);
    });
  });
});
