/**
 * Property-Based Tests for MCPManagerService
 * Feature: mcp-integration, Property 4: Agent Tool Access Restriction
 * Validates: Requirements 1.4, 4.3
 */

import * as fc from 'fast-check';
import { MCPManagerService } from '../MCPManagerService';

// Mock dependencies
jest.mock('../../../config/database');
jest.mock('../../../utils/encryption');
jest.mock('../MCPClient');

describe('MCPManagerService Property Tests', () => {
  let service: MCPManagerService;

  beforeEach(() => {
    service = new MCPManagerService();
  });

  /**
   * Property 4: Agent Tool Access Restriction
   * For any agent with selected MCP tools, that agent should only be able to invoke tools in its allowed list
   */
  describe('Property 4: Mode Switching Preserves Agent Data', () => {
    it('should handle mode switching without data loss', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uuid(),
          fc.constantFrom('auto-generated', 'bring-your-own'),
          fc.constantFrom('auto-generated', 'bring-your-own'),
          async (userId: string, initialMode: 'auto-generated' | 'bring-your-own', targetMode: 'auto-generated' | 'bring-your-own') => {
            // Property: Switching modes should be idempotent if already in target mode
            if (initialMode === targetMode) {
              // Mock getMCPConfig to return config with current mode
              const mockConfig = {
                id: fc.sample(fc.uuid(), 1)[0],
                userId,
                mode: initialMode,
                name: 'Test Config',
                status: 'active' as const,
                createdAt: new Date(),
                updatedAt: new Date(),
              };

              jest.spyOn(service, 'getMCPConfig').mockResolvedValue(mockConfig as any);
              
              // Should not throw and should be idempotent
              await expect(service.switchMCPMode(userId, targetMode)).resolves.not.toThrow();
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should reject mode switching for non-existent configs', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uuid(),
          fc.constantFrom('auto-generated', 'bring-your-own'),
          async (userId: string, targetMode: 'auto-generated' | 'bring-your-own') => {
            // Mock getMCPConfig to return null (no config)
            jest.spyOn(service, 'getMCPConfig').mockResolvedValue(null);
            
            // Property: Should throw error when no config exists
            await expect(service.switchMCPMode(userId, targetMode))
              .rejects.toThrow('No MCP configuration found');
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  describe('Property: MCP Config Creation', () => {
    it('should reject duplicate MCP configs for same user', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uuid(),
          fc.string({ minLength: 1, maxLength: 100 }),
          fc.string({ minLength: 10, maxLength: 1000 }),
          async (userId: string, name: string, apiDoc: string) => {
            // Mock getMCPConfig to return existing config
            const existingConfig = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              mode: 'auto-generated' as const,
              name: 'Existing Config',
              status: 'active' as const,
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(service, 'getMCPConfig').mockResolvedValue(existingConfig as any);
            
            // Property: Should throw error when config already exists
            await expect(service.createAutoGeneratedMCP(userId, apiDoc, name))
              .rejects.toThrow('User already has an MCP configuration');
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  describe('Property: Connection Validation', () => {
    it('should validate connection before creating BYO-MCP', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uuid(),
          fc.webUrl(),
          fc.record({
            type: fc.constantFrom('none', 'bearer', 'api-key'),
            credentials: fc.option(fc.string(), { nil: undefined }),
          }),
          async (userId: string, serverUrl: string, auth: any) => {
            // Mock getMCPConfig to return null (no existing config)
            jest.spyOn(service, 'getMCPConfig').mockResolvedValue(null);
            
            // Mock validateConnection to return false
            jest.spyOn(service, 'validateConnection').mockResolvedValue(false);
            
            // Property: Should reject invalid connections
            await expect(service.createBYOMCP(userId, serverUrl, auth))
              .rejects.toThrow('Failed to validate MCP server connection');
          }
        ),
        { numRuns: 50 }
      );
    });

    it('should handle various URL formats in validation', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.oneof(
            fc.webUrl(),
            fc.webUrl({ withFragments: true }),
            fc.webUrl({ withQueryParameters: true })
          ),
          async (serverUrl: string) => {
            // Property: Validation should handle various URL formats
            const result = await service.validateConnection(serverUrl);
            
            // Should return boolean (true or false, not throw)
            expect(typeof result).toBe('boolean');
          }
        ),
        { numRuns: 50 }
      );
    });
  });
});
