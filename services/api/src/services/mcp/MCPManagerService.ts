import { query } from '../../config/database';
import { AppError } from '../../middleware/errorHandler';
import { MCPClient, MCPTool, MCPConnectionConfig } from './MCPClient';
import { encrypt, decrypt } from '../../utils/encryption';

export interface MCPConfig {
  id: string;
  userId: string;
  mode: 'auto-generated' | 'bring-your-own';
  name: string;
  status: 'active' | 'inactive' | 'error';
  createdAt: Date;
  updatedAt: Date;
}

export interface AutoGeneratedMCPConfig extends MCPConfig {
  mode: 'auto-generated';
  apiDocumentation: string;
  generatedTools: MCPTool[];
  internalServerUrl: string;
}

export interface BYOMCPConfig extends MCPConfig {
  mode: 'bring-your-own';
  externalServerUrl: string;
  authType: 'none' | 'bearer' | 'api-key';
  discoveredTools: MCPTool[];
}

export interface AuthConfig {
  type: 'none' | 'bearer' | 'api-key';
  credentials?: string;
}

export class MCPManagerService {
  /**
   * Create auto-generated MCP configuration
   */
  async createAutoGeneratedMCP(
    userId: string,
    apiDoc: string,
    name: string = 'Auto-generated MCP'
  ): Promise<AutoGeneratedMCPConfig> {
    try {
      // Check if user already has an MCP config
      const existing = await this.getMCPConfig(userId);
      if (existing) {
        throw new AppError(400, 'MCP_ALREADY_EXISTS', 'User already has an MCP configuration');
      }

      // Create MCP config record
      const result = await query(
        `INSERT INTO mcp_configs (user_id, mode, name, api_documentation, status)
         VALUES ($1, $2, $3, $4, $5)
         RETURNING *`,
        [userId, 'auto-generated', name, apiDoc, 'active']
      );

      const config = result.rows[0];

      return {
        id: config.id,
        userId: config.user_id,
        mode: 'auto-generated',
        name: config.name,
        status: config.status,
        apiDocumentation: config.api_documentation,
        generatedTools: config.generated_tools || [],
        internalServerUrl: config.internal_server_url || '',
        createdAt: config.created_at,
        updatedAt: config.updated_at,
      };
    } catch (error) {
      if (error instanceof AppError) throw error;
      throw new AppError(
        500,
        'MCP_CREATE_FAILED',
        `Failed to create auto-generated MCP: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Create bring-your-own MCP configuration
   */
  async createBYOMCP(
    userId: string,
    serverUrl: string,
    auth: AuthConfig,
    name: string = 'Bring-your-own MCP'
  ): Promise<BYOMCPConfig> {
    try {
      // Check if user already has an MCP config
      const existing = await this.getMCPConfig(userId);
      if (existing) {
        throw new AppError(400, 'MCP_ALREADY_EXISTS', 'User already has an MCP configuration');
      }

      // Validate connection first
      const isValid = await this.validateConnection(serverUrl, auth);
      if (!isValid) {
        throw new AppError(400, 'MCP_CONNECTION_INVALID', 'Failed to validate MCP server connection');
      }

      // Encrypt credentials if provided
      let encryptedCredentials: string | null = null;
      if (auth.credentials) {
        encryptedCredentials = encrypt(auth.credentials);
      }

      // Create MCP config record
      const result = await query(
        `INSERT INTO mcp_configs (user_id, mode, name, external_server_url, auth_type, encrypted_credentials, status)
         VALUES ($1, $2, $3, $4, $5, $6, $7)
         RETURNING *`,
        [userId, 'bring-your-own', name, serverUrl, auth.type, encryptedCredentials, 'active']
      );

      const config = result.rows[0];

      // Discover tools from the server
      const tools = await this.discoverTools(config);

      // Update config with discovered tools
      await query(
        `UPDATE mcp_configs SET discovered_tools = $1 WHERE id = $2`,
        [JSON.stringify(tools), config.id]
      );

      return {
        id: config.id,
        userId: config.user_id,
        mode: 'bring-your-own',
        name: config.name,
        status: config.status,
        externalServerUrl: config.external_server_url,
        authType: config.auth_type,
        discoveredTools: tools,
        createdAt: config.created_at,
        updatedAt: config.updated_at,
      };
    } catch (error) {
      if (error instanceof AppError) throw error;
      throw new AppError(
        500,
        'MCP_CREATE_FAILED',
        `Failed to create BYO-MCP: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Get MCP configuration for a user
   */
  async getMCPConfig(userId: string): Promise<MCPConfig | null> {
    try {
      const result = await query(
        `SELECT * FROM mcp_configs WHERE user_id = $1`,
        [userId]
      );

      if (result.rows.length === 0) {
        return null;
      }

      const config = result.rows[0];

      if (config.mode === 'auto-generated') {
        return {
          id: config.id,
          userId: config.user_id,
          mode: 'auto-generated',
          name: config.name,
          status: config.status,
          apiDocumentation: config.api_documentation,
          generatedTools: config.generated_tools || [],
          internalServerUrl: config.internal_server_url || '',
          createdAt: config.created_at,
          updatedAt: config.updated_at,
        } as AutoGeneratedMCPConfig;
      } else {
        return {
          id: config.id,
          userId: config.user_id,
          mode: 'bring-your-own',
          name: config.name,
          status: config.status,
          externalServerUrl: config.external_server_url,
          authType: config.auth_type,
          discoveredTools: config.discovered_tools || [],
          createdAt: config.created_at,
          updatedAt: config.updated_at,
        } as BYOMCPConfig;
      }
    } catch (error) {
      throw new AppError(
        500,
        'MCP_GET_FAILED',
        `Failed to get MCP config: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Switch MCP mode
   */
  async switchMCPMode(
    userId: string,
    newMode: 'auto-generated' | 'bring-your-own'
  ): Promise<void> {
    try {
      const existing = await this.getMCPConfig(userId);
      if (!existing) {
        throw new AppError(404, 'MCP_NOT_FOUND', 'No MCP configuration found for user');
      }

      if (existing.mode === newMode) {
        return; // Already in the desired mode
      }

      // Delete existing config
      await query(`DELETE FROM mcp_configs WHERE user_id = $1`, [userId]);

      // Note: Agents will need to be updated separately
      // The mcp_config_id will be set to NULL due to ON DELETE SET NULL
    } catch (error) {
      if (error instanceof AppError) throw error;
      throw new AppError(
        500,
        'MCP_SWITCH_FAILED',
        `Failed to switch MCP mode: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Discover tools from MCP server
   */
  async discoverTools(config: any): Promise<MCPTool[]> {
    try {
      const connectionConfig: MCPConnectionConfig = {
        serverUrl: config.external_server_url || config.internal_server_url,
        authType: config.auth_type,
        credentials: config.encrypted_credentials ? decrypt(config.encrypted_credentials) : undefined,
      };

      const client = new MCPClient(connectionConfig);
      await client.connect();

      const tools = await client.listTools();
      await client.disconnect();

      // Store tools in mcp_tools table for caching
      for (const tool of tools) {
        await query(
          `INSERT INTO mcp_tools (mcp_config_id, name, description, input_schema)
           VALUES ($1, $2, $3, $4)
           ON CONFLICT (mcp_config_id, name) DO UPDATE
           SET description = $2, input_schema = $3, updated_at = NOW()`,
          [config.id, tool.name, tool.description, JSON.stringify(tool.inputSchema)]
        );
      }

      return tools;
    } catch (error) {
      throw new AppError(
        500,
        'MCP_DISCOVER_FAILED',
        `Failed to discover tools: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Invoke a tool
   */
  async invokeTool(
    mcpConfig: MCPConfig,
    toolName: string,
    params: any
  ): Promise<any> {
    try {
      let serverUrl: string;
      let authType: 'none' | 'bearer' | 'api-key' | undefined;
      let credentials: string | undefined;

      if (mcpConfig.mode === 'auto-generated') {
        const autoConfig = mcpConfig as AutoGeneratedMCPConfig;
        serverUrl = autoConfig.internalServerUrl;
        authType = 'none';
      } else {
        const byoConfig = mcpConfig as BYOMCPConfig;
        serverUrl = byoConfig.externalServerUrl;
        authType = byoConfig.authType;

        // Get encrypted credentials from database
        const result = await query(
          `SELECT encrypted_credentials FROM mcp_configs WHERE id = $1`,
          [mcpConfig.id]
        );
        if (result.rows[0]?.encrypted_credentials) {
          credentials = decrypt(result.rows[0].encrypted_credentials);
        }
      }

      const connectionConfig: MCPConnectionConfig = {
        serverUrl,
        authType,
        credentials,
      };

      const client = new MCPClient(connectionConfig);
      await client.connect();

      const result = await client.callTool(toolName, params);
      await client.disconnect();

      return result;
    } catch (error) {
      throw new AppError(
        500,
        'MCP_INVOKE_FAILED',
        `Failed to invoke tool: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Validate MCP server connection
   */
  async validateConnection(serverUrl: string, auth?: AuthConfig): Promise<boolean> {
    try {
      const connectionConfig: MCPConnectionConfig = {
        serverUrl,
        authType: auth?.type || 'none',
        credentials: auth?.credentials,
      };

      const client = new MCPClient(connectionConfig);
      await client.connect();
      
      // Try to list tools as a validation
      await client.listTools();
      
      await client.disconnect();
      return true;
    } catch (error) {
      console.error('MCP connection validation failed:', error);
      return false;
    }
  }
}

export default new MCPManagerService();
