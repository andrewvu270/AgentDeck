# Design Document

## Overview

AgentDeck will support two MCP modes: auto-generated MCP (where an analyzer agent creates MCP from client APIs) and bring-your-own MCP (where clients provide their own MCP server configuration). This design enables flexible agent deployment while maintaining security and ease of use. The system will integrate the Model Context Protocol SDK to enable agents to invoke tools, access resources, and perform actions in client applications.

## Architecture

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                        AgentDeck Platform                    │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐         ┌──────────────┐                  │
│  │   Frontend   │────────▶│   Backend    │                  │
│  │  (React UI)  │         │  (Express)   │                  │
│  └──────────────┘         └──────┬───────┘                  │
│                                   │                           │
│                    ┌──────────────┼──────────────┐           │
│                    │              │              │           │
│            ┌───────▼──────┐ ┌────▼─────┐ ┌─────▼──────┐    │
│            │  Analyzer    │ │   MCP    │ │   Agent    │    │
│            │   Agent      │ │ Manager  │ │ Orchestrator│   │
│            └──────────────┘ └────┬─────┘ └─────┬──────┘    │
│                                   │              │           │
└───────────────────────────────────┼──────────────┼───────────┘
                                    │              │
                    ┌───────────────┴──────┐       │
                    │                      │       │
            ┌───────▼────────┐    ┌───────▼───────▼─────┐
            │  Auto-Generated│    │   BYO-MCP Server    │
            │   MCP Server   │    │  (Client-Provided)  │
            └────────────────┘    └─────────────────────┘
```

### Component Breakdown

1. **MCP Manager**
   - Handles MCP mode selection (auto-generated vs BYO)
   - Manages MCP server connections
   - Discovers and caches available tools
   - Routes tool invocations to appropriate MCP servers

2. **Analyzer Agent**
   - Parses client API documentation (OpenAPI, GraphQL, REST)
   - Generates MCP tool definitions
   - Categorizes tools by role
   - Creates MCP server configuration

3. **Agent Orchestrator**
   - Creates agent sessions with MCP tool access
   - Coordinates multi-agent conversations
   - Manages workspace chat
   - Handles tool invocation requests from agents

4. **MCP Server (Auto-Generated)**
   - Implements MCP protocol
   - Exposes generated tools to agents
   - Proxies requests to client APIs
   - Handles authentication and rate limiting

## Components and Interfaces

### 1. MCP Manager Service

```typescript
interface MCPConfig {
  id: string;
  userId: string;
  mode: 'auto-generated' | 'bring-your-own';
  name: string;
  status: 'active' | 'inactive' | 'error';
  createdAt: Date;
  updatedAt: Date;
}

interface AutoGeneratedMCPConfig extends MCPConfig {
  mode: 'auto-generated';
  apiDocumentation: string; // OpenAPI/GraphQL spec
  generatedTools: MCPTool[];
  serverUrl: string; // Internal MCP server URL
}

interface BYOMCPConfig extends MCPConfig {
  mode: 'bring-your-own';
  serverUrl: string;
  authType: 'none' | 'bearer' | 'api-key';
  encryptedCredentials?: string;
  discoveredTools: MCPTool[];
}

interface MCPTool {
  name: string;
  description: string;
  inputSchema: JSONSchema;
  outputSchema: JSONSchema;
  roles: string[]; // Which agent roles can use this tool
  category: string; // Dev, QA, Product, Analytics, etc.
}

class MCPManagerService {
  async createAutoGeneratedMCP(userId: string, apiDoc: string): Promise<AutoGeneratedMCPConfig>;
  async createBYOMCP(userId: string, serverUrl: string, auth: AuthConfig): Promise<BYOMCPConfig>;
  async getMCPConfig(userId: string): Promise<MCPConfig | null>;
  async switchMCPMode(userId: string, newMode: 'auto-generated' | 'bring-your-own'): Promise<void>;
  async discoverTools(mcpConfig: MCPConfig): Promise<MCPTool[]>;
  async invokeTool(mcpConfig: MCPConfig, toolName: string, params: any): Promise<any>;
  async validateConnection(serverUrl: string, auth?: AuthConfig): Promise<boolean>;
}
```

### 2. Analyzer Agent Service

```typescript
interface APIAnalysisResult {
  endpoints: APIEndpoint[];
  dataModels: DataModel[];
  authRequirements: AuthRequirement[];
  suggestedTools: MCPTool[];
}

interface APIEndpoint {
  path: string;
  method: string;
  description: string;
  parameters: Parameter[];
  responses: Response[];
  suggestedRole: string[];
}

class AnalyzerAgentService {
  async analyzeOpenAPI(spec: string): Promise<APIAnalysisResult>;
  async analyzeGraphQL(schema: string): Promise<APIAnalysisResult>;
  async analyzeRESTDocs(docs: string): Promise<APIAnalysisResult>;
  async generateMCPTools(analysis: APIAnalysisResult): Promise<MCPTool[]>;
  async categorizeToolsByRole(tools: MCPTool[]): Promise<Map<string, MCPTool[]>>;
  async createMCPServer(tools: MCPTool[], clientAuth: AuthConfig): Promise<string>;
}
```

### 3. Agent Service (Enhanced)

```typescript
interface AgentWithMCP extends Agent {
  mcpTools: string[]; // Tool names this agent can access
  mcpConfigId: string;
}

class AgentService {
  async createAgentWithMCP(
    userId: string,
    agentData: AgentData,
    selectedTools: string[]
  ): Promise<AgentWithMCP>;
  
  async updateAgentTools(
    agentId: string,
    userId: string,
    tools: string[]
  ): Promise<void>;
  
  async getAvailableTools(
    userId: string,
    role?: string
  ): Promise<MCPTool[]>;
  
  async executeWithMCP(
    agentId: string,
    userId: string,
    input: string
  ): Promise<ExecutionResult>;
}
```

### 4. MCP Client Wrapper

```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

class MCPClient {
  private client: Client;
  private transport: StdioClientTransport;
  
  async connect(serverUrl: string, auth?: AuthConfig): Promise<void>;
  async listTools(): Promise<MCPTool[]>;
  async callTool(name: string, arguments: any): Promise<any>;
  async disconnect(): Promise<void>;
}
```

## Data Models

### Database Schema Updates

```sql
-- MCP Configurations table
CREATE TABLE mcp_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  mode VARCHAR(20) NOT NULL CHECK (mode IN ('auto-generated', 'bring-your-own')),
  name VARCHAR(255) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'active',
  
  -- Auto-generated MCP fields
  api_documentation TEXT,
  generated_tools JSONB,
  internal_server_url TEXT,
  
  -- BYO-MCP fields
  external_server_url TEXT,
  auth_type VARCHAR(20),
  encrypted_credentials TEXT,
  discovered_tools JSONB,
  
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(user_id) -- One MCP config per user
);

-- MCP Tools table (for caching and quick lookup)
CREATE TABLE mcp_tools (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mcp_config_id UUID NOT NULL REFERENCES mcp_configs(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  input_schema JSONB NOT NULL,
  output_schema JSONB,
  roles TEXT[] DEFAULT '{}',
  category VARCHAR(50),
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(mcp_config_id, name)
);

-- Update agents table to include MCP tool access
ALTER TABLE agents ADD COLUMN mcp_tools TEXT[] DEFAULT '{}';
ALTER TABLE agents ADD COLUMN mcp_config_id UUID REFERENCES mcp_configs(id);

-- MCP Tool Invocations (for logging and analytics)
CREATE TABLE mcp_tool_invocations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
  tool_name VARCHAR(255) NOT NULL,
  parameters JSONB,
  result JSONB,
  error TEXT,
  duration_ms INTEGER,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_mcp_tool_invocations_agent ON mcp_tool_invocations(agent_id);
CREATE INDEX idx_mcp_tool_invocations_created ON mcp_tool_invocations(created_at);
```

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

### Property 1: MCP Mode Selection Persistence
*For any* user, when they select an MCP mode (auto-generated or bring-your-own), that selection should persist across sessions and be retrievable
**Validates: Requirements 1.1, 1.5**

### Property 2: Analyzer Agent Tool Generation Completeness
*For any* valid API documentation, the analyzer agent should generate at least one MCP tool for each documented endpoint
**Validates: Requirements 2.2**

### Property 3: BYO-MCP Connection Validation
*For any* MCP server URL and credentials, the system should validate the connection before saving the configuration
**Validates: Requirements 3.2**

### Property 4: Agent Tool Access Restriction
*For any* agent with selected MCP tools, that agent should only be able to invoke tools in its allowed list
**Validates: Requirements 4.3**

### Property 5: MCP Tool Invocation Logging
*For any* MCP tool invocation by an agent, the system should create a log entry with tool name, parameters, and result
**Validates: Requirements 6.1**

### Property 6: Credential Encryption Round-Trip
*For any* MCP server credentials, encrypting then decrypting should produce the original credentials
**Validates: Requirements 7.1**

### Property 7: Tool Discovery Consistency
*For any* MCP configuration, discovering tools multiple times should return the same set of tools (assuming server hasn't changed)
**Validates: Requirements 3.3**

### Property 8: Role-Based Tool Filtering
*For any* agent role and MCP configuration, the available tools should only include tools tagged with that role
**Validates: Requirements 4.2**

## Error Handling

### MCP Connection Errors
- **Timeout**: Retry with exponential backoff (3 attempts)
- **Authentication Failure**: Return clear error to user, don't retry
- **Network Error**: Retry once, then fail gracefully
- **Invalid Response**: Log error, return user-friendly message

### Analyzer Agent Errors
- **Invalid API Documentation**: Return validation errors with line numbers
- **Parsing Failure**: Attempt multiple parsers, fallback to manual configuration
- **Tool Generation Failure**: Generate partial tools, flag incomplete ones

### Tool Invocation Errors
- **Tool Not Found**: Return error to agent, suggest available tools
- **Invalid Parameters**: Validate before sending, return schema validation errors
- **Execution Timeout**: Cancel after 30s, return timeout error
- **Rate Limit Exceeded**: Queue request or return rate limit error

## Testing Strategy

### Unit Tests
- MCP Manager: connection validation, tool discovery, mode switching
- Analyzer Agent: API parsing, tool generation, role categorization
- MCP Client: tool invocation, error handling, connection management
- Agent Service: tool access control, MCP integration

### Integration Tests
- End-to-end MCP setup flow (auto-generated)
- End-to-end MCP setup flow (BYO)
- Agent creation with MCP tools
- Tool invocation from agent execution
- Multi-agent workspace with MCP tools

### Property-Based Tests
- Use `fast-check` library for JavaScript/TypeScript
- Each correctness property will have a corresponding property-based test
- Minimum 100 iterations per property test
- Tests will be tagged with property numbers for traceability

## Security Considerations

1. **Credential Storage**
   - All MCP credentials encrypted with AES-256-GCM
   - Encryption keys stored in environment variables
   - Never log or expose credentials in responses

2. **Tool Access Control**
   - Agents can only invoke tools in their allowed list
   - Validate tool access before every invocation
   - Log all tool invocations for audit trail

3. **Rate Limiting**
   - Per-user rate limits on MCP tool invocations
   - Per-agent rate limits to prevent runaway executions
   - Configurable limits based on subscription tier

4. **Input Validation**
   - Validate all tool parameters against JSON schema
   - Sanitize inputs before sending to MCP servers
   - Prevent injection attacks through parameter validation

## Implementation Notes

### MCP SDK Integration
```typescript
// Install dependencies
npm install @modelcontextprotocol/sdk zod

// Example MCP client usage
import { Client } from '@modelcontextprotocol/sdk/client/index.js';

const client = new Client({
  name: 'agentdeck-client',
  version: '1.0.0'
});

await client.connect(transport);
const tools = await client.listTools();
const result = await client.callTool('createTask', { title: 'New Task' });
```

### Analyzer Agent Implementation
- Use GPT-4 or Claude for API analysis
- Provide structured prompts with examples
- Parse LLM output into MCP tool definitions
- Validate generated tools before saving

### Auto-Generated MCP Server
- Create lightweight Node.js MCP server per client
- Use Docker containers for isolation
- Proxy tool calls to client APIs
- Handle authentication and rate limiting

## Deployment Considerations

1. **MCP Server Hosting**
   - Auto-generated MCP servers run as Docker containers
   - One container per client configuration
   - Managed by Docker Compose or Kubernetes
   - Auto-scaling based on usage

2. **Database Migrations**
   - Add new tables for MCP configs and tools
   - Migrate existing agents to include MCP fields
   - Backfill data for existing users

3. **Backward Compatibility**
   - Existing agents continue to work without MCP
   - Gradual migration path for users
   - Feature flag for MCP functionality

## Future Enhancements

1. **MCP Marketplace**
   - Pre-built MCP configurations for popular APIs
   - Community-contributed MCP tools
   - One-click MCP setup for common platforms

2. **Advanced Analyzer Agent**
   - Learn from user corrections
   - Suggest tool improvements
   - Auto-update tools when APIs change

3. **Multi-MCP Support**
   - Allow users to configure multiple MCP sources
   - Agents can access tools from multiple MCPs
   - Unified tool discovery and invocation
